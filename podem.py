# -*- coding: utf-8 -*-
"""PODEM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11XpTCFtPxF6FdaRbVQCRiXs21gaRpaBf
"""

import copy
f=open("netlist10.txt","r")
l=f.readlines();

def read_netlist():
    nd_id=0;
    for i in range (0, len(l)):
        temp=l[i]
        temp_str=''
        nd=[]
        if(temp=='\n'):
            continue
        else:
            nd.append(nd_id) 
            nd_id=nd_id+1  
        flag=0;
        z=len(temp)
        w=temp[len(temp)-1]
        print(w)
        for j in range (0, len(temp)):
            #ewc=temp[j]
            if (j==len(temp)-1):
                if (temp[j] != ' ' or temp[j] == '\n'):
                    if(temp_str):
                        nd.append(temp_str)
                        temp_str=''
                        print(nd)
                else:
                    if(temp_str):
                        nd.append(temp_str)
                        temp_str=''
            elif (temp[j] !=' '):
                temp_str = temp_str + temp[j]
            else:
                if(temp_str):
                    nd.append(temp_str)
                temp_str=''
        netlist.append(nd) 
    
def convert_netlist():
    temp=1
    node_old =[]
    node_new =[]
    for i in range (0, len(netlist)):
        if (netlist[i][1][:5] == 'and2_'):
            netlist[i][1] = 3;
        elif (netlist[i][1][:3] == 'not'):
            netlist[i][1] = 1;
        elif (netlist[i][1][:6] == 'nand4_'):
            netlist[i][1] = 8;
        elif (netlist[i][1][:6] == 'nand2_'):
            netlist[i][1] = 5;
        elif (netlist[i][1][:4] == 'or2_'):
            netlist[i][1] = 9;
            
        for j in range (2,len(netlist[i])):
            if (netlist[i][j][:2] == 'in'):
                match=0
                for k in range (0, len(node_old)):
                    if (netlist[i][j] == node_old[k]):
                        match=1
                        break
                        
                if (match):        
                    netlist[i][j]=node_new[k]
                else:                    
                    ins.append(temp)
                    node_old.append(netlist[i][j])
                    node_new.append(temp)
                    netlist[i][j]=temp
                    temp=temp+1
                    
            elif (netlist[i][j][:3] == 'out'):
                match=0
                for k in range (0, len(node_old)):
                    if (netlist[i][j] == node_old[k]):
                        match=1
                        break
                        
                if (match):        
                    netlist[i][j]=node_new[k]
                else:                    
                    outs.append(temp)
                    node_old.append(netlist[i][j])
                    node_new.append(temp)
                    netlist[i][j]=temp
                    temp=temp+1
            else:
                match=0
                for k in range (0, len(node_old)):
                    if (netlist[i][j] == node_old[k]):
                        match=1
                        break
                        
                if (match):        
                    netlist[i][j]=node_new[k]
                else:
                    node_old.append(netlist[i][j])
                    node_new.append(temp)
                    netlist[i][j]=temp
                    temp=temp+1
    for i in range(0, len(node_old)):
        temp2 = []
        temp2.append(node_old[i])
        temp2.append(node_new[i])
        node_map.append(temp2)
        
    return (temp -1)

def values_initial (no_nodes):
 
    for i in range (0, no_nodes+1):
        node_values.append(-5) 

def nand_out(o,i1,i2,g):

    if (g==0):          
        if(o == -5):
            i1= i1 ; 
            i2= i2;
            o=o;      
        elif(o == 0):
            i1 = 1; i2 = 1;
        elif(o == 1):
            if (i1 == 1):  
                i2= 0;
            elif(i2 == 1): 
                    i1= 0;
            elif (i1== 0):
                i2= i2;
            elif (i2== 0):
                i1= i1;
            else:
                i1=0;
                i2=0;


    else:
        if(i1 == -5 and i2 == -5):
            o =-5;
        else:
            o1 = (i1*i2) ;
            if(abs(o1)>1): 
                o = -5;
            else:
                o = int(not(o1));
    return[o,i1,i2] 

def not_out(o,i1,g):
    if(g==0):
        if(o==-5):
            i1 = -5;
        else:    
            i1 = int(not(o))
    else:
        if(i1==-5):
            o = -5;
        else:    
            o = int(not(i1));
    return[o,i1]

def and_out(o,i1,i2,g):
    if (g==0):          
        if(o == -5):
            i1= i1 ; 
            i2= i2;
            o=o;      
        elif(o == 1):
            i1 = 1; i2 = 1;
        elif(o == 0):
            if (i1 == 1):  
                i2= 0;
            elif(i2 == 1): 
                i1= 0;
            elif(i1== 0):
                i2= i2;
            elif(i2== 0):
                i1= i1;
            else:
                i1=0;
                i2=0;
    else:
        if(i1 == -5 and i2 == -5):
            o =-5;
        else:
            o1 = (i1*i2) ;
            if(abs(o1)>1): 
                o = -5;
            else:
                o = o1;
    return[o,i1,i2] 

def or_out(o,i1,i2,g):
    if (g==0):          
        if(o == -5):
            i1= i1 ; 
            i2= i2;
            o=o;      
        elif(o == 0):
            i1 = 0; i2 = 0;
        elif(o == 1):
            if (i1 == 1):  
                i2= i2;
            elif (i2 == 1): 
                i1= i1;
            elif (i1== 0):
                i2= 1;
            elif (i2== 0):
                i1= 1;
            else:
                i1=1;
                i2=1;
    else:
        if(i1 == -5 and i2 == -5):
            o =-5;
        else:
            o1 = (i1|i2) ;
            if(abs(o1)>1): 
                o = -5;
            else:
                o = o1;
    return[o,i1,i2]

def nand_4input(o,i1,i2,i3,i4,g):
    if(g==0):
        if(o==-5):
            i1 = i2 = i3 = i4 = -5;
        if(o == 0):
            i1 = i2 = i3 = i4 = 1;
        elif (o==1): 
            i1 = 0;
    elif(g==1):
        o1 = (i1*i2*i3*i4) ;
        if(abs(o1)>1): 
            o = -5;
        else:
            o = int(not(o1));
    return(o,i1,i2,i3,i4);

def nand_3input(o,i1,i2,i3,g):
    if(g==0):
        if(o==-5):
            i1 = i2 = i3 = -5;
        if(o == 0):
            i1 = i2 = i3 = 1;
        elif (o==1): 
            i1 = 0;
    elif(g==1):
        o1 = (i1*i2*i3) ;
        if(abs(o1)>1): 
            o = -5;
        else:
            o = int(not(o1));
    return(o,i1,i2,i3);
         

def Type(V,row):
    g=0; 
    row_update = copy.deepcopy(row);
    if(V == -5): 
        row_update = copy.deepcopy(row)
        print('Value of V is not allowed')
    else:
        if(int(row[1])==1):
            row_update[2:5] =  not_out(V,row[3],g);
        elif(int(row[1])==3):
            row_update[2:5] =  and_out( V, row[3], row[4], g);
        elif(int(row[1])==5):
            row_update[2:5] =  nand_out( V, row[3], row[4], g); 
        elif(int(row[1])==8):
            row_update[2:7] =  nand_4input( V, row[3], row[4],row[5],row[6],g);
        elif(int(row[1])==9):
            row_update[2:5] =  or_out( V, row[3], row[4], g);

    return row_update

def update_rowvalues(nd_id):
    rowvector=[]
    rowvector.append(nd_id)
    rowvector.append(netlist[nd_id][1])
    
    for i in range (2, len(netlist[nd_id])):
        rowvector.append(node_values[netlist[nd_id][i]])
    return rowvector 

def backtrace(nG, nV):
    for i in range (0,len(netlist)): 
        if ( int(netlist[i][2]) == nG):
            row_values = update_rowvalues(i)
            row_v = Type(nV,row_values)

            for j in range (0, len(row_v)-3):

                g = int(netlist[i][3+j]) ;
                v = row_v[3+j];
                m =  [g,v]
                stack_G.append(m)
              
def objective(nG, nV):
    isPI=0
    while(nV !=-5 and isPI == 0):
        for i in range (0, len(ins)):
            if (nG == ins[i]):
                isPI=1
                break
        if (isPI==1):
            return (nG, nV)
        else:
            backtrace(nG,nV)
            
            if(stack_G):
                (nG,nV) = stack_G.pop()
            #isPI=0
        
    return (nG, nV)

def type_imply(row_imply):
    g=1;
    row_update = copy.deepcopy(row_imply);
    temp =int(row_imply[1]);
    if(temp==1):
        [row_update[2],row_update[3] ]= not_out(row_update[2], row_imply[3],g);
    elif(temp==3):
        [row_update[2],row_update[3],row_update[4] ] = and_out( row_update[2], row_imply[3], row_imply[4],g) ;
    elif(temp==5):
        [row_update[2],row_update[3],row_update[4] ] = nand_out(row_update[2],row_imply[3], row_imply[4], g); 
    elif(temp==8):
        [row_update[2],row_update[3],row_update[4],row_update[5],row_update[6]] = nand_4input( row_update[2], row_imply[3], row_imply[4], row_imply[5], row_imply[6],g);
    elif(temp==9):
        [row_update[2],row_update[3],row_update[4] ] = or_out(row_update[2],row_imply[3], row_imply[4], g); 
    return row_update



def cnctd_nds (c_Node):
    nd_index = []
    for i in range (0,len(netlist)):
        for j in range(3,len(netlist[i])):
            if(c_Node == netlist[i][j]):
                nd_index.append(i);
                
    return nd_index

''''''
def cnctd_devices2(c_Node):  ##understood
    device_index = []
    for k in range(0,len(c_Node)):
        for i in range (0,len(netlist)):
            for j in range(3,len(netlist[i])):
                if(c_Node[k] == netlist[i][j]):
                    device_index.append(i)
    device_index=list(set(device_index))            
    return device_index
def inp_cnctd_devices(Node_inp):
    device_inds = []
    for j in range(0,len(netlist)):
        for k in range(3,len(netlist[j])):
            if(Node_inp==netlist[j][k]):
                device_inds.append(j)
    return device_inds
# find device connected to each node once 
# one time job


def create_ndmap():
    
    for i in range (0, len(netlist)):
        
        nd_map.append (cnctd_nds (netlist[i][2]));

def imply_nd(nd_id):
    
    row_imply = update_rowvalues(nd_id)
    row_update = type_imply(row_imply)
    node_values [netlist[nd_id][2]] = row_update[2]

       
def imply(PI, PI_Value):
    count_OUT = []
    flag=0
    node_values[PI] = PI_Value
    nd_connected_next = []
    while (len(count_OUT) != len(outs)):
        if(flag==0):
            flag = 1
            nd_connected = cnctd_nds(PI)
            for i in range (0, len(nd_connected)):
                imply_nd(nd_connected[i])
                       
        else:
            flag = flag +1
            nd_connected = nd_connected_next
            nd_connected_next = []
            
            for i in range(0, len(nd_connected)):
                imply_nd(nd_connected[i])
            
            
           
        next_d = []
        check=0
        for i in range (0, len(nd_connected)):
                nd_map_copy = copy.deepcopy(nd_map)
                next_d = nd_map_copy[nd_connected[i]]
            
            # check if temp_d is empty
                if (len(next_d)==0):
                    
                    match_out = False
                    
                    for i1 in range (0, len(count_OUT)):
                        if (count_OUT[i1] == nd_connected[i]):
                            match_out = True
                            break
                    if (~match_out):
                        count_OUT.append(nd_connected[i])
                   
                if(next_d):
                        x = -1
                        while (len(next_d) > 0):
                            x = next_d.pop()
                            match_12 = False
                            for i2 in range(0, len(nd_connected_next)):                         
                                
                                if(x==nd_connected_next[i2]):
                                    match_12 = True
                                    break
                                    
                            if(~match_12):
                                    nd_connected_next.append(x)
                                    nd_connected_next = list(set(nd_connected_next))
                check=check+1;

def main_podem(nG_C, nV):
    read_netlist()
    no_nodes = convert_netlist()
    create_ndmap()
    values_initial(no_nodes)
    for i in range(1, len(node_map)):
        if(nG_C == node_map[i][0]):
            nG = node_map[i][1]
            FL = node_map[i][1]

    (PI, PI_V) = objective(nG, (nV+1)%2)        

    imply(PI, PI_V)
    count=0
    while(node_values[FL] == -5):
        if(stack_G):
            (nG,nV) = stack_G.pop()
        else:
            print("Error")
            return
        (PI, PI_V) = objective(nG, nV)
        imply(PI, PI_V)
        count=count+1
    node_values[FL]=nV
    connected_out1=[]
    connected_out1.append(FL)
    index_arr1=cnctd_devices2(connected_out1)
    connected_out2=[]
    if(len(index_arr1)!=0):
        for i in range(0,len(index_arr1)):
            connected_out2.append(netlist[index_arr1[i]][2])
    index_arr2=cnctd_devices2(connected_out2)
    # print('index_arr2:',index_arr2)
    connected_out3=[]
    if(len(index_arr2)!=0):
        for i in range(0,len(index_arr2)):
            connected_out3.append(netlist[index_arr2[i]][2])
    index_arr=index_arr1+index_arr2

    k = len(index_arr)
    if(k==0):
        #fault at primary output
        if (FV==node_values[FL] ):
            print('Fault is detectable')
        else:
            print('Fault is not detectable')
    
    for j in range (0, len(index_arr)):
        count = 0 ;
        nc_value = 1
        connected_in = netlist[index_arr[j]][3:len(netlist[index_arr[j]])]
        for p in range(0, len(connected_in)):
            if(connected_in[p] != FL):
                if(node_values[connected_in[p]] == -5):
                    (PI, PI_V) = objective(connected_in[p], nc_value)
                    imply(PI, PI_V)
                    if(node_values[connected_in[p]] == nc_value):
                        count = count + 1;
                elif(node_values[connected_in[p]] == nc_value): 
                    count = count +1
                elif(node_values[connected_in[p]] == (1-nc_value)):
                    print('Test not detected')
                    break
        if(count == (len(connected_in)-1)): 
            print('Fault is detectable')
            print (' ')
            print('Primary Input values are:')
            for i in range (0, len(ins)):
                if(node_values[ins[i]]==-5):
                    print (node_map[ins[i]][0]," ",'x')
                else:
                    print (node_map[ins[i]][0]," ",node_values[ins[i]])

        else:
            print('Fault is not detectable')
    #return (PI, PI_V)

netlist=[]
node_values = []        
ins=[]
outs=[]
nd_map = []
stack_G = []
node_map=[[]]

Fault_Location = 'n1'
Fault_Value = 0;

FL = 0;
FV = Fault_Value

print ('Fault Location', Fault_Location)
print ('Fault Value', FV)
main_podem(Fault_Location,FV)